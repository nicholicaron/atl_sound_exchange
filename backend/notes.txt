GO vs RUST for web api's

Pro Rust:
     - Data processing capabilities
     - Error handling
     - generics
     - Closure serialization (makes 'moving compute to data' [hadoop/spark] easier)
     - Clean interface to C (not sure if this will be relevant to this project)
     -

Pro Go (GoPro? lol):
     - Far more ergonomic for this sorta thing
     - Better libraries


REMEMBER TO USE SOMETHING OTHER THAN FROM_STR FOR ARTIST_DATA STRUCTS
     - JSON Files will be way too large
     - from_reader()?

From_reader deserializes an instance directly from an IO stream of JSON without being buffered in memory by serde_json
     - will not work with a persistent socket connection


Cross-Origin Resource Sharing (https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)
 "an HTTP-header based mechanism that allows a server to indicate any origins other than its
 own from which a browser should permit loading resources"




Artist Struct
     Background (Struct)
         Name
         Place of Origin (Location(String))
         Genre(s)
         description (String)
         Top songs [Song; 10]
     deezer (JSON)
     instagram (JSON)
     soundcloud (JSON)
     spotify (JSON)
     tiktok (JSON)
     twitter (JSON)
     yt_artist (JSON)
     yt_channel (JSON)

Song Struct
     Title
     Link
Genre Enum
Origin Enum

CSV vs JSON?
     CSV is more bandwidth friendly as you don't have
to parse out the syntax, just separate by character

     JSON has more ergonomic Rust support with serde

Cannot nest structs because size must be known at compile time
Instead look into RC/ARC/Box<T>
     Rc and Arc treat their contents as immutable, if you need mutation,
     you need to combine them with something (Rc: RefCell/ Arc: RwLock)

RwLock: Allows many readers simultaneously but just one writer at a time
     - Need async implementation of RwLock
         + parking_lot library
     - Will become poisoned if panic occurs while it is locked in write mode
     - Use try_read() instead of read() : attempts to acquire lock, does not block, returns
     result<RAII guard, Poisoned Error>
     - Use try_write() instead or write() : attempts to acquire lock, does not block, returns
     result<RAII guard, {Poisoned Err|WouldBlock Err}>

                             Potential deadlocks???
--------------------------------------------------------------------------
             Thread 1                    |           Thread 2            |
         let _rg = lock.read();          |                               |
                                         |       [will block]            |
                                         |   let _wg = lock.write();     |
             [may deadlock]              |                               |
         let _rg = lock.read();          |                               |
--------------------------------------------------------------------------


Rough JSON structure:
 - rank: u16,
 - change: String,
 - country: string,
 - popularity: u8 <--------------- maybe this should go in Background
 - internal_link: String <-------- maybe this should go in Background
 - peak_position: u16
 - peak_date: String <------------ maybe parse into 3-tuple
 - seven_day_velocity: f32,
 - total_days_on_chart: String,
 - current_streak: u16 <---------- meaning?




